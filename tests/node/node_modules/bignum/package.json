{
  "name": "bignum",
  "version": "0.5.1",
  "description": "Arbitrary-precision integer arithmetic using OpenSSL",
  "main": "./index.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/justmoon/node-bignum.git"
  },
  "keywords": [
    "gmp",
    "libgmp",
    "big",
    "bignum",
    "bigint",
    "integer",
    "arithmetic",
    "precision"
  ],
  "author": {
    "name": "Stefan Thomas",
    "email": "justmoon@members.fsf.org",
    "url": "http://www.justmoon.net"
  },
  "devDependencies": {
    "expresso": ">=0.6.0",
    "binary": ">=0.1.7",
    "put": ">=0.0.5"
  },
  "license": "MIT/X11",
  "engine": {
    "node": ">=0.8.0"
  },
  "scripts": {
    "install": "node-gyp configure build",
    "test": "expresso"
  },
  "contributors": [
    {
      "name": "James Halliday",
      "email": "mail@substack.net"
    }
  ],
  "readme": "bignum\n======\n\nArbitrary precision integral arithmetic for Node.js using\nOpenSSL.\n\nThis library is based on\n[node-bigint](https://github.com/substack/node-bigint) by\n[substack](https://github.com/substack), but instead of using libgmp,\nit uses the builtin bignum functionality from OpenSSL. The advantage\nis that OpenSSL is already a soft dependency of Node.js and therefore\noften already installed on systems with Node.js.\n\ndifferences\n===========\n\nWhen switching from node-bigint to node-bignum, please be aware of\nthese differences:\n\n- Bignum rounds towards zero for integer divisions, e.g. `10 / -3 = -3`, whereas bigint\n  rounds towards negative infinity, e.g. `10 / -3 = -4`.\n- Boolean operations (and, or, xor) are not supported.\n\nexample\n=======\n\nsimple.js\n---------\n\n    var bignum = require('bignum');\n    \n    var b = bignum('782910138827292261791972728324982')\n        .sub('182373273283402171237474774728373')\n        .div(8)\n    ;\n    console.log(b);\n\n***\n    $ node simple.js\n    <Bignum 75067108192986261319312244199576>\n\nperfect.js\n----------\n\nGenerate the perfect numbers:\n\n    // If 2**n-1 is prime, then (2**n-1) * 2**(n-1) is perfect.\n    var bignum = require('bignum');\n\n    for (var n = 0; n < 100; n++) {\n        var p = bignum.pow(2, n).sub(1);\n        if (p.probPrime(50)) {\n            var perfect = p.mul(bignum.pow(2, n - 1));\n            console.log(perfect.toString());\n        }\n    }\n\n***\n\n    6\n    28\n    496\n    8128\n    33550336\n    8589869056\n    137438691328\n    2305843008139952128\n    2658455991569831744654692615953842176\n    191561942608236107294793378084303638130997321548169216\n\nmethods[0]\n==========\n\nbignum(n, base=10)\n------------------\n\nCreate a new `bignum` from `n` and a base. `n` can be a string, integer, or\nanother `bignum`.\n\nIf you pass in a string you can set the base that string is encoded in.\n\n.toString(base=10)\n------------------\n\nPrint out the `bignum` instance in the requested base as a string.\n\nbignum.fromBuffer(buf, opts)\n----------------------\n\nCreate a new `bignum` from a `Buffer`.\n\nThe default options are:\n    {\n        order : 'forward', // low-to-high indexed word ordering\n        endian : 'big',\n        size : 1, // number of bytes in each word\n    }\n\nNote that endian doesn't matter when size = 1.\n\nmethods[1]\n==========\n\nFor all of the instance methods below you can write either\n\n    bignum.method(x, y, z)\n\nor if x is a `bignum` instance``\n\n    x.method(y, z)\n\n.toNumber()\n-----------\n\nTurn a `bignum` into a `Number`. If the `bignum` is too big you'll lose\nprecision or you'll get Â±`Infinity`.\n\n.toBuffer(opts)\n-------------\n\nReturn a new `Buffer` with the data from the `bignum`.\n\nThe default options are:\n    {\n        order : 'forward', // low-to-high indexed word ordering\n        endian : 'big',\n        size : 1, // number of bytes in each word\n    }\n\nNote that endian doesn't matter when size = 1.\n\n.add(n)\n-------\n\nReturn a new `bignum` containing the instance value plus `n`.\n\n.sub(n)\n-------\n\nReturn a new `bignum` containing the instance value minus `n`.\n\n.mul(n)\n-------\n\nReturn a new `bignum` containing the instance value multiplied by `n`.\n\n.div(n)\n-------\n\nReturn a new `bignum` containing the instance value integrally divided by `n`.\n\n.abs()\n------\n\nReturn a new `bignum` with the absolute value of the instance.\n\n.neg()\n------\n\nReturn a new `bignum` with the negative of the instance value.\n\n.cmp(n)\n-------\n\nCompare the instance value to `n`. Return a positive integer if `> n`, a\nnegative integer if `< n`, and 0 if `== n`.\n\n.gt(n)\n------\n\nReturn a boolean: whether the instance value is greater than n (`> n`).\n\n.ge(n)\n------\n\nReturn a boolean: whether the instance value is greater than or equal to n\n(`>= n`).\n\n.eq(n)\n------\n\nReturn a boolean: whether the instance value is equal to n (`== n`).\n\n.lt(n)\n------\n\nReturn a boolean: whether the instance value is less than n (`< n`).\n\n.le(n)\n------\n\nReturn a boolean: whether the instance value is less than or equal to n\n(`<= n`).\n\n.and(n)\n-------\n\nReturn a new `bignum` with the instance value bitwise AND (&)-ed with `n`.\n\n.or(n)\n------\n\nReturn a new `bignum` with the instance value bitwise inclusive-OR (|)-ed with\n`n`.\n\n.xor(n)\n-------\n\nReturn a new `bignum` with the instance value bitwise exclusive-OR (^)-ed with\n`n`.\n\n.mod(n)\n-------\n\nReturn a new `bignum` with the instance value modulo `n`.\n\n`m`.\n.pow(n)\n-------\n\nReturn a new `bignum` with the instance value raised to the `n`th power.\n\n.powm(n, m)\n-----------\n\nReturn a new `bignum` with the instance value raised to the `n`th power modulo\n`m`.\n\n.invertm(m)\n-----------\n\nCompute the multiplicative inverse modulo `m`.\n\n.rand()\n-------\n.rand(upperBound)\n-----------------\n\nIf `upperBound` is supplied, return a random `bignum` between the instance value\nand `upperBound - 1`, inclusive.\n\nOtherwise, return a random `bignum` between 0 and the instance value - 1,\ninclusive.\n\n.probPrime()\n------------\n\nReturn whether the bignum is:\n\n* certainly prime (true)\n* probably prime ('maybe')\n* certainly composite (false)\n\nusing [mpz_probab_prime](http://gmplib.org/manual/Number-Theoretic-Functions.html).\n\n.nextPrime()\n------------\n\nReturn the next prime greater than `this` using\n[mpz_nextprime](http://gmplib.org/manual/Number-Theoretic-Functions.html).\n\n.sqrt()\n-------\n\nReturn a new `bignum` that is the square root.  This truncates.\n\n.root(n)\n-------\n\nReturn a new `bignum` that is the `nth` root.  This truncates.\n\n.shiftLeft(n)\n-------\n\nReturn a new `bignum` that is the `2^n` multiple. Equivalent of the <<\noperator.\n\n.shiftRight(n)\n-------\n\nReturn a new `bignum` of the value integer divided by\n`2^n`. Equivalent of the >> operator.\n\ninstall\n=======\n\nYou'll need the libssl (OpenSSL) source to compile this package. If\nyou compiled Node.js using the official instructions, you'll already\nhave it. Otherwise install it using the instructions below.\n\nUnder Debian-based systems,\n\n    sudo aptitude install libssl3-dev\n\nOn a Mac with [Homebrew](https://github.com/mxcl/homebrew/),\n\n    brew install openssl\n\nAnd then install with [npm](http://npmjs.org):\n\n    npm install bignum\n",
  "_id": "bignum@0.5.1",
  "dist": {
    "shasum": "4fac4fb16ab998198a271a9a01804b12790c386f"
  },
  "_from": "bignum"
}
